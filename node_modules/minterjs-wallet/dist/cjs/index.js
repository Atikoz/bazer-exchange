"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
exports.generateMnemonic = generateMnemonic;
exports.generateWallet = generateWallet;
exports.hdKeyFromSeed = hdKeyFromSeed;
exports.isValidMnemonic = isValidMnemonic;
exports.seedFromMnemonic = seedFromMnemonic;
exports.seedFromMnemonicAsync = seedFromMnemonicAsync;
exports.walletFromMnemonic = walletFromMnemonic;
exports.walletFromMnemonicAsync = walletFromMnemonicAsync;
exports.walletFromPrivateKey = walletFromPrivateKey;

var bip39 = _interopRequireWildcard(require("bip39"));

var _hdkey = require("ethereum-cryptography/hdkey");

var _account = require("ethereumjs-util/dist/account");

var _minterjsUtil = require("minterjs-util");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// @TODO remove some wordlists
function assert(val, msg) {
  if (!val) {
    throw new Error(msg || 'Assertion failed');
  }
}
/**
 * BIP39 Master seed from mnemonic phrase
 * @param mnemonic - 12 words
 * @return {Buffer}
 */


function seedFromMnemonic(mnemonic) {
  return bip39.mnemonicToSeedSync(mnemonic);
}
/**
 * BIP39 Master seed from mnemonic phrase (async)
 * @param mnemonic - 12 words
 * @return {Promise<Buffer>}
 */


function seedFromMnemonicAsync(mnemonic) {
  return bip39.mnemonicToSeed(mnemonic);
}
/**
 * @typedef {{purpose?: number, coin?: number, account?: number, change?: number, index?: number}} HDKeyPathObject
 */

/**
 * @typedef {string|HDKeyPathObject} HDKeyPath
 */

/**
 * BIP44 HD key from master seed
 * https://en.bitcoin.it/wiki/BIP_0044
 * @param {Buffer} seed - 64 bytes
 * @param {HDKeyPath} [path] - Ethereum path by default "m/44'/60'/0'/0/0"
 * @return {HDKey}
 */


function hdKeyFromSeed(seed) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof path !== 'string') {
    var _path = path,
        _path$purpose = _path.purpose,
        purpose = _path$purpose === void 0 ? 44 : _path$purpose,
        _path$coin = _path.coin,
        coin = _path$coin === void 0 ? 60 : _path$coin,
        _path$account = _path.account,
        account = _path$account === void 0 ? 0 : _path$account,
        _path$change = _path.change,
        change = _path$change === void 0 ? 0 : _path$change,
        _path$index = _path.index,
        index = _path$index === void 0 ? 0 : _path$index;
    path = "m/".concat(purpose, "'/").concat(coin, "'/").concat(account, "'/").concat(change, "/").concat(index);
  }

  return _hdkey.HDKey.fromMasterSeed(seed).derive(path);
}
/**
 * @param {Buffer} [priv]
 * @param {string} [mnemonic]
 * @param {boolean} [doAsync]
 * @constructor
 */


var Wallet = function WalletConstructor(priv, mnemonic, doAsync, hdPath) {
  var _this = this;

  if (priv && mnemonic) {
    throw new Error('Cannot supply both a private and a mnemonic phrase to the constructor');
  }

  if (priv && !(0, _account.isValidPrivate)(priv)) {
    throw new Error('Private key does not satisfy the curve requirements (ie. it is invalid)');
  }

  if (mnemonic && !bip39.validateMnemonic(mnemonic)) {
    throw new Error('Invalid mnemonic phrase');
  }

  if (mnemonic && doAsync) {
    return seedFromMnemonicAsync(mnemonic).then(function (seed) {
      _this._privKey = hdKeyFromSeed(seed, hdPath)._privateKey;
      _this._mnemonic = mnemonic;
      return _this;
    });
  }

  if (mnemonic) {
    var seed = seedFromMnemonic(mnemonic);
    priv = hdKeyFromSeed(seed, hdPath)._privateKey;
  }

  this._privKey = priv;
  this._mnemonic = mnemonic;
};

Object.defineProperty(Wallet.prototype, 'mnemonic', {
  get: function get() {
    assert(this._mnemonic, 'This is a private key only wallet');
    return this._mnemonic;
  }
});
Object.defineProperty(Wallet.prototype, 'privKey', {
  get: function get() {
    return this._privKey;
  }
}); // uncompressed public key

Object.defineProperty(Wallet.prototype, 'pubKey', {
  get: function get() {
    if (!this._pubKey) {
      this._pubKey = (0, _account.privateToPublic)(this.privKey);
    }

    return this._pubKey;
  }
});
/**
 * @return {string}
 */

Wallet.prototype.getMnemonic = function getMnemonic() {
  return this.mnemonic;
};
/**
 * @return {Buffer}
 */


Wallet.prototype.getPrivateKey = function getPrivateKey() {
  return this.privKey;
};
/**
 * @return {string}
 */


Wallet.prototype.getPrivateKeyString = function getPrivateKeyString() {
  return "0x".concat(this.getPrivateKey().toString('hex'));
};
/**
 * @return {Buffer}
 */


Wallet.prototype.getPublicKey = function getPublicKey() {
  return this.pubKey;
};
/**
 * @return {string}
 */


Wallet.prototype.getPublicKeyString = function getPublicKeyString() {
  return (0, _minterjsUtil.publicToString)(this.getPublicKey());
};
/**
 * @return {Buffer}
 */


Wallet.prototype.getAddress = function getAddress() {
  return (0, _account.publicToAddress)(this.pubKey);
};
/**
 * @return {string}
 */


Wallet.prototype.getAddressString = function getAddressString() {
  return "Mx".concat(this.getAddress().toString('hex'));
};
/**
 * Generate Wallet from random mnemonic
 * @param {HDKeyPath} [path]
 * @return {Wallet}
 */


function generateWallet(path) {
  var mnemonic = bip39.generateMnemonic();
  return walletFromMnemonic(mnemonic, path);
}
/**
 * MinterWallet from mnemonic phrase
 * @param {string} mnemonic - 12 words
 * @param {HDKeyPath} [path]
 * @return {Wallet}
 */


function walletFromMnemonic(mnemonic, path) {
  return new Wallet(undefined, mnemonic, false, path);
}
/**
 * MinterWallet from mnemonic phrase
 * @param {string} mnemonic - 12 words
 * @param {HDKeyPath} [path]
 * @return {Promise<Wallet>}
 */


function walletFromMnemonicAsync(mnemonic, path) {
  return new Wallet(undefined, mnemonic, true, path);
}
/**
 * MinterWallet from private key
 * @param {Buffer} priv - 64 bytes
 * @return {Wallet}
 */


function walletFromPrivateKey(priv) {
  return new Wallet(priv);
}
/**
 * Generate 12 words mnemonic phrase
 * @return {string}
 */


function generateMnemonic() {
  return bip39.generateMnemonic();
}
/**
 * Check that mnemonic phrase has 12 words and represents valid entropy
 * @param {string} mnemonic
 * @return {boolean}
 */


function isValidMnemonic(mnemonic) {
  return typeof mnemonic === 'string' && mnemonic.trim().split(/\s+/g).length >= 12 && bip39.validateMnemonic(mnemonic);
}

var _default = Wallet;
exports["default"] = _default;