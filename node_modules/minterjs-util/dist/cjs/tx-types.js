"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TX_TYPE = void 0;
exports.normalizeTxType = normalizeTxType;
exports.txTypeList = void 0;
var _ethjsUtil = require("ethjs-util");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
/**
 * @enum {string} TX_TYPE
 */
var TX_TYPE = {
  SEND: '0x01',
  SELL: '0x02',
  SELL_ALL: '0x03',
  BUY: '0x04',
  CREATE_COIN: '0x05',
  DECLARE_CANDIDACY: '0x06',
  DELEGATE: '0x07',
  UNBOND: '0x08',
  REDEEM_CHECK: '0x09',
  SET_CANDIDATE_ON: '0x0A',
  SET_CANDIDATE_OFF: '0x0B',
  CREATE_MULTISIG: '0x0C',
  MULTISEND: '0x0D',
  EDIT_CANDIDATE: '0x0E',
  SET_HALT_BLOCK: '0x0F',
  RECREATE_COIN: '0x10',
  EDIT_TICKER_OWNER: '0x11',
  EDIT_MULTISIG: '0x12',
  PRICE_VOTE: '0x13',
  EDIT_CANDIDATE_PUBLIC_KEY: '0x14',
  ADD_LIQUIDITY: '0x15',
  REMOVE_LIQUIDITY: '0x16',
  SELL_SWAP_POOL: '0x17',
  BUY_SWAP_POOL: '0x18',
  SELL_ALL_SWAP_POOL: '0x19',
  EDIT_CANDIDATE_COMMISSION: '0x1A',
  MOVE_STAKE: '0x1B',
  MINT_TOKEN: '0x1C',
  BURN_TOKEN: '0x1D',
  CREATE_TOKEN: '0x1E',
  RECREATE_TOKEN: '0x1F',
  VOTE_COMMISSION: '0x20',
  VOTE_UPDATE: '0x21',
  CREATE_SWAP_POOL: '0x22',
  ADD_LIMIT_ORDER: '0x23',
  REMOVE_LIMIT_ORDER: '0x24',
  LOCK_STAKE: '0x25',
  LOCK: '0x26'
};
exports.TX_TYPE = TX_TYPE;
var DISABLED_TYPES = _defineProperty({}, TX_TYPE.PRICE_VOTE, true);

// swap: keys <=> values
var txTypeKeys = Object.fromEntries(Object.entries(TX_TYPE).map(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
    key = _ref2[0],
    hexValue = _ref2[1];
  return [hexValue, key];
}));

/**
 * @typedef {Object} TxTypeItem
 * @property {TX_TYPE} hex
 * @property {string} name
 * @property {number} number
 * @property {string} key
 * @property {boolean} isDisabled
 */

/** @type {Array<TxTypeItem>} */
var txTypeList = [];

/**
 * @param hex
 * @param [name]
 * @return {TxTypeItem}
 */
exports.txTypeList = txTypeList;
function fillList(hex, name) {
  var result = {};
  result.key = txTypeKeys[hex].toLowerCase();
  result.name = name || result.key.replace(/_/g, ' ');
  result.number = Number(hex);
  result.hex = hex;
  result.isDisabled = !!DISABLED_TYPES[hex];
  txTypeList[result.number] = result;
  return result;
}
fillList(TX_TYPE.SEND);
fillList(TX_TYPE.SELL);
fillList(TX_TYPE.SELL_ALL);
fillList(TX_TYPE.BUY);
fillList(TX_TYPE.CREATE_COIN);
fillList(TX_TYPE.DECLARE_CANDIDACY);
fillList(TX_TYPE.DELEGATE);
fillList(TX_TYPE.UNBOND);
fillList(TX_TYPE.REDEEM_CHECK);
fillList(TX_TYPE.SET_CANDIDATE_ON);
fillList(TX_TYPE.SET_CANDIDATE_OFF);
fillList(TX_TYPE.CREATE_MULTISIG);
fillList(TX_TYPE.MULTISEND);
fillList(TX_TYPE.EDIT_CANDIDATE);
fillList(TX_TYPE.SET_HALT_BLOCK, 'vote for halt block');
fillList(TX_TYPE.RECREATE_COIN);
fillList(TX_TYPE.EDIT_TICKER_OWNER);
fillList(TX_TYPE.EDIT_MULTISIG);
fillList(TX_TYPE.PRICE_VOTE, 'vote for price');
fillList(TX_TYPE.EDIT_CANDIDATE_PUBLIC_KEY);
fillList(TX_TYPE.ADD_LIQUIDITY, 'add liquidity to pool');
fillList(TX_TYPE.REMOVE_LIQUIDITY, 'remove liquidity from pool');
fillList(TX_TYPE.SELL_SWAP_POOL, 'sell within pool');
fillList(TX_TYPE.BUY_SWAP_POOL, 'buy within pool');
fillList(TX_TYPE.SELL_ALL_SWAP_POOL, 'sell all within pool');
fillList(TX_TYPE.EDIT_CANDIDATE_COMMISSION);
fillList(TX_TYPE.MOVE_STAKE);
fillList(TX_TYPE.MINT_TOKEN);
fillList(TX_TYPE.BURN_TOKEN);
fillList(TX_TYPE.CREATE_TOKEN);
fillList(TX_TYPE.RECREATE_TOKEN);
fillList(TX_TYPE.VOTE_COMMISSION, 'vote for commission price');
fillList(TX_TYPE.VOTE_UPDATE, 'vote for network update');
fillList(TX_TYPE.CREATE_SWAP_POOL);
fillList(TX_TYPE.ADD_LIMIT_ORDER);
fillList(TX_TYPE.REMOVE_LIMIT_ORDER);
fillList(TX_TYPE.LOCK_STAKE);
fillList(TX_TYPE.LOCK);
/**
 *
 * @param {TX_TYPE|number|string|Buffer|Uint8Array} txType
 * @return {TX_TYPE}
 */
function normalizeTxType(txType) {
  if (!txType) {
    throw new Error("Invalid tx type: ".concat(txType));
  }
  // Buffer or Uint8Array to TX_TYPE
  if (txType.length > 0 && typeof txType !== 'string') {
    txType = Buffer.from(txType).toString('hex');
    txType = "0x".concat(txType);
  }
  // invalid string to number
  if (typeof txType === 'string' && txType.indexOf('0x') !== 0 && txType.indexOf('0X') !== 0) {
    txType = Number.parseInt(txType, 10);
  }
  // number to TX_TYPE
  if (typeof txType === 'number') {
    txType = (0, _ethjsUtil.padToEven)(txType.toString(16));
    txType = "0x".concat(txType);
  }
  txType = txType.toUpperCase();
  txType = txType.replace(/^0X/, '0x');
  if (!Object.values(TX_TYPE).includes(txType)) {
    throw new Error('Invalid tx type');
  }
  return txType;
}